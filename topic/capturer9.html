<!DOCTYPE html>
<html>
	<head>
		<title>capturer9</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link
			href="examples/demo/demo.css"
			media="screen, print"
			rel="stylesheet"
			type="text/css"
		/>
	</head>
	<style>
		#info {
			position: absolute;
			top: 0px;
			width: 100%;
			padding: 10px;
			text-align: center;
			color: #f3bbe0;
		}

		body {
			overflow: hidden;
		}
	</style>

	<body>
		<div id="info">
			<h1>Finite State Machine --capturer</h1>
		</div>

		<script src="state-machine.js"></script>
		<!-- script src="examples/demo/demo.js"></script-->
		<script src="https://threejs.org/build/three.min.js"></script>
		<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
		<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
		<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
		<script>
			(function () {
				Math.clamp = function (val, min, max) {
					return Math.min(Math.max(val, min), max);
				};
			})();

			class Obstacle {
				constructor(center, size) {
					this.center = center.clone();
					this.mesh = new THREE.Mesh(
						new THREE.CylinderGeometry(size, size, 1, 20),
						new THREE.MeshBasicMaterial()
					);
					this.mesh.position.copy(center);
					this.size = size;
					scene.add(this.mesh);
				}
			}

			class Avatar {
				constructor(pos, mesh) {
					this.pos = pos.clone();
					this.vel = new THREE.Vector3();
					this.force = new THREE.Vector3();
					this.MAXSPEED = 50;
					this.ARRIVAL_R = 30;

					this.target = null;
					this.steermode = "";
					this.BRAKING = 0;
					this.size = 3;
					this.mesh = mesh;
					scene.add(mesh);

					// for orientable agent
					this.angle = 0;
				}

				update(dt) {
					//console.log ('in avatar update ...');

					this.accumulateForce();
					this.vel.add(this.force.clone().multiplyScalar(dt));

					// ARRIVAL: velocity modulation
					if (this.target !== null) {
						let diff = this.target.clone().sub(this.pos);
						let dst = diff.length();
						if (dst < this.ARRIVAL_R) {
							this.vel.setLength(dst);
						}
					}

					// MAXSPEED modulation
					let speed = this.vel.length();
					this.vel.setLength(Math.clamp(speed, 0, this.MAXSPEED));
					this.pos.add(this.vel.clone().multiplyScalar(dt));
					this.mesh.position.copy(this.pos);

					// for orientable agent
					if (this.vel.length() > 0.1) {
						this.angle = Math.atan2(-this.vel.z, this.vel.x);
						this.mesh.rotation.y = this.angle;
					}
					// collision
					// for all obstacles in the scene
					let obs = scene.obstacles;

					// pick the most threatening one
					let theOne = null;
					let dist = 1e10;
					let vhat = this.vel.clone().normalize();
					const REACH = 50;
					const K = 5;
					let perp;
					for (let i = 0; i < obs.length; i++) {
						let point = obs[i].center.clone().sub(this.pos); // c-p
						let proj = point.dot(vhat);
						if (proj > 0 && proj < REACH) {
							perp = new THREE.Vector3();
							perp.subVectors(
								point,
								vhat.clone().setLength(proj)
							);
							let overlap =
								obs[i].size + this.size - perp.length();
							if (overlap > 0 && proj < dist) {
								theOne = obs[i];
								dist = proj;
								perp.setLength(K * overlap);
								perp.negate();
							}
						}
					}
					if (theOne) this.force.add(perp);

					this.vel.add(this.force.clone().multiplyScalar(dt));
				}

				// target, SEEK & FLEE
				setSeekTarget(x, y, z) {
					this.BRAKING = 0;
					this.steerMode = "SEEK";
					this._setTarget(x, y, z);
				}

				setFleeTarget(x, y, z) {
					this.BRAKING = 0;
					this.steerMode = "FLEE";
					this._setTarget(x, y, z);
				}

				_setTarget(x, y, z) {
					// do not use outside class
					if (this.target !== null) this.target.set(x, y, z);
					else {
						this.target = new THREE.Vector3(x, y, z);
					}
				}

				targetInducedForce(targetPos) {
					let sign = 0;
					if (this.steerMode === "SEEK") sign = 1;
					else if (this.steerMode === "FLEE") sign = -1;

					return targetPos
						.clone()
						.sub(this.pos)
						.normalize()
						.multiplyScalar(sign * this.MAXSPEED)
						.sub(this.vel);
				}

				setBrake(brake) {
					// make the avatar stop gracefully
					this.BRAKING = brake;
					this.target = null; // release target
				}
				accumulateForce() {
					if (this.target)
						this.force.copy(this.targetInducedForce(this.target));
					else this.force.set(0, 0, 0); // for null-target initial force

					// braking ...
					this.force.add(
						this.vel.clone().multiplyScalar(-this.BRAKING)
					);
				}
			}

			class Agent extends Avatar {
				constructor(pos, mesh, name = "", fsm) {
					super(pos, mesh);
					this.fsm = fsm;
					// initial state got from fsm.state;
					this.stateSign = null;
				}

				update(dt) {
					//console.log("in agent update ...");
					super.update(dt); // calling avatar update
					if (this.fsm) {
						$("#preyState").text(this.fsm.state);

						if (this.fsm.state === "snatch") {
							super.setSeekTarget(
								flag.position.x,
								0,
								flag.position.z
							);
						}
						if (this.fsm.state === "search") {
							var angle = Math.PI / 5;
							var v = this.mesh.localToWorld(
								new THREE.Vector3(
									10 * Math.cos(angle),
									0,
									-10 * Math.sin(angle)
								)
							);
							/*.sub(
									this.mesh.localToWorld(
										new THREE.Vector3(0, 0, 0)
									)
								);*/
							super.setSeekTarget(v.x, 0, v.z);
							//super.setBrake(10);
							/*super.setSeekTarget(
								this.pos.x + 10,
								0,
								this.pos.z + 10
							);*/
						}
					}
					if (this.stateSign) {
						this.stateSign.position.copy(this.pos);
						this.stateSign.position.y = 20;
						this.stateSign.lookAt(
							camera.position.x,
							10,
							camera.position.z
						);

						if (this.fsm.state === "snatch") {
							this.stateSign.children[0].material.visible = true;
							this.stateSign.children[1].material.visible = false;
						}
						if (this.fsm.state === "search") {
							this.stateSign.children[1].material.visible = true;
							this.stateSign.children[0].material.visible = false;
						}
					}
				}
				/*showState() {
					if (this.state === "search") {
						search.position.set(this.pos.x, 15, this.pos.z);
						scene.add(search);
					}
					if (this.state === "snatch") {
						snatch.position.set(this.pos.x, 15, this.pos.z);
						scene.add(snatch);
					}
				}*/
				findTarget(target) {
					var point = target.position.clone().sub(this.pos);
					var v = this.mesh
						.localToWorld(new THREE.Vector3(1, 0, 0))
						.sub(this.mesh.localToWorld(new THREE.Vector3(0, 0, 0)))
						.normalize();
					var CosineValue = v.dot(point);
					if (CosineValue > 0) {
						front = true;
					} else {
						front = false;
					}
				}
			}

			function initFSM() {
				let fsm = new StateMachine({
					init: "search",
					transitions: [
						{
							name: "flagFound",
							from: "search",
							to: "snatch",
						},
						{
							name: "flagFound",
							from: "snatch",
							to: "snatch",
						},
						{
							name: "flagNoFound",
							from: "snatch",
							to: "search",
						},
						{
							name: "flagNoFound",
							from: "search",
							to: "search",
						},
					],
				});
				return fsm;
			}
			var scene, camera, renderer;
			var clock;
			var keyboard = new KeyboardState();
			var raycaster, ray;
			var mouse = new THREE.Vector2();
			var pickables = [],
				pickables2 = [];
			var front = false,
				behind = false;
			var flag;
			var prey, predictor;
			init();
			initFSM();

			animate();

			function agentMesh(scale = 1, _color = "cyan") {
				// mesh facing +x

				let points = [];

				points.push(
					new THREE.Vector3(10 * scale, 0, 0),
					new THREE.Vector3(0, 0, -3 * scale),
					new THREE.Vector3(0, 0, 3 * scale),
					new THREE.Vector3(0, 3 * scale, 0)
				);
				let geometry = new THREE.BufferGeometry().setFromPoints(points);

				let indices = [];
				indices.push(0, 3, 2, 0, 2, 1, 1, 3, 0, 1, 2, 3);
				geometry.setIndex(indices);
				geometry.computeFaceNormals();
				return new THREE.Mesh(
					geometry,
					new THREE.MeshBasicMaterial({
						color: _color,
						wireframe: true,
					})
				);
			}

			function stateSign() {
				let loader = new THREE.TextureLoader();
				let snatchMap = loader.load("https://i.imgur.com/L67LiqY.png");
				let searchMap = loader.load("https://i.imgur.com/ui0cEeC.png");

				let snatchMesh = new THREE.Mesh(
					new THREE.PlaneGeometry(35, 30),
					new THREE.MeshBasicMaterial({
						map: snatchMap,
						transparent: true,
						alphaTest: 1,
						side: THREE.DoubleSide,
					})
				);
				let searchMesh = new THREE.Mesh(
					new THREE.PlaneGeometry(35, 20),
					new THREE.MeshBasicMaterial({
						map: searchMap,
						transparent: true,
						alphaTest: 1,
						side: THREE.DoubleSide,
					})
				);
				let preyStateSign = new THREE.Group();
				preyStateSign.add(snatchMesh, searchMesh);
				return preyStateSign;
			}
			function init() {
				clock = new THREE.Clock();
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(
					50,
					window.innerWidth / window.innerHeight,
					1,
					1000
				);
				camera.position.set(0, 200, 200);

				var gridXZ = new THREE.GridHelper(240, 24, "red", "white");
				scene.add(gridXZ);

				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0x888888);

				let controls = new THREE.OrbitControls(
					camera,
					renderer.domElement
				);

				document.body.appendChild(renderer.domElement);
				document.addEventListener(
					"pointerdown",
					onDocumentMouseDown,
					false
				);
				raycaster = new THREE.Raycaster();
				ray = new THREE.Raycaster();
				///////////////////////////////////////////////////////////
				plane = new THREE.Mesh(
					new THREE.PlaneGeometry(240, 240),
					new THREE.MeshBasicMaterial({
						transparent: true,
						opacity: 0.5,
						visible: true,
					})
				);
				scene.add(plane);
				plane.material.visible = false;
				plane.rotation.x = -Math.PI / 2;
				pickables = [plane];
				///////////////////////////////////////////////////////////
				predictor = new Agent(
					randomPosZX(-100, 100),
					agentMesh(2, "red"),
					"T-Rex"
				);
				//console.log(preditor.pos);

				prey = new Agent(
					randomPosZX(-100, 100),
					agentMesh(1, "cyan"),
					"sheep",
					initFSM()
				);
				prey.stateSign = stateSign();
				scene.add(prey.stateSign);

				///////////////////////////////////////////////////////////
				let loader = new THREE.TextureLoader();
				loader.crossOrigin = "";
				let tex = loader.load("https://i.imgur.com/8SMMBtP.png");
				flag = new THREE.Mesh(
					new THREE.CircleGeometry(10, 20),
					new THREE.MeshBasicMaterial({
						map: tex,
						transparent: true,
						side: THREE.DoubleSide,
					})
				);
				flag.position.set(0, 5, 0);
				flag.name = "flag";
				scene.add(flag);

				scene.obstacles = [];
				scene.obstacles.push(
					new Obstacle(new THREE.Vector3(50, 0, 50), 15)
				);
				scene.obstacles.push(
					new Obstacle(new THREE.Vector3(-50, 0, 40), 15)
				);
				scene.obstacles.push(
					new Obstacle(new THREE.Vector3(0, 0, 30), 15)
				);
				pickables2.push(
					flag,
					scene.obstacles[0].mesh,
					scene.obstacles[1].mesh,
					scene.obstacles[2].mesh
				);
				///////////////////////////////////////////////////////////
			}
			function randomPosZX(min, max) {
				let x = min + (max - min) * Math.random();
				let z = min + (max - min) * Math.random();

				return new THREE.Vector3(x, 0, z); //x,0,z);
			}

			/*function preyBrain(prey) {
				if (prey.pos.distanceTo(predictor.pos) < 40) {
					found = true;
					prey.setFleeTarget(
						predictor.pos.x,
						predictor.pos.y,
						predictor.pos.z
					);
				} else if (near && !found) {
					fsm.flagFound();
				} else if (!near && !found) {
					fsm.flagNoFound();
				} else {
					prey.target = null;
					// also: to make it stop then idle ...
					prey.vel.setLength(0);
				}
			}*/

			function update() {
				keyboard.update();

				if (keyboard.pressed("left")) {
					predictor.setSeekTarget(
						predictor.pos.x - 15,
						0,
						predictor.pos.z
					);
					//predictor.position.x -= 0.2;
				}
				if (keyboard.pressed("right")) {
					predictor.setSeekTarget(
						predictor.pos.x + 15,
						0,
						predictor.pos.z
					);
					//predictor.position.x += 0.2;
				}
				if (keyboard.pressed("up")) {
					predictor.setSeekTarget(
						predictor.pos.x,
						0,
						predictor.pos.z - 15
					);

					//predictor.position.z -= 0.2;
				}

				if (keyboard.pressed("down")) {
					predictor.setSeekTarget(
						predictor.pos.x,
						0,
						predictor.pos.z + 15
					);
					//predictor.position.z += 0.2;
				}
			}
			function behindOrNot() {
				let point = prey.mesh
					.localToWorld(new THREE.Vector3(1, 0, 0))
					.sub(prey.mesh.localToWorld(new THREE.Vector3(0, 0, 0)))
					.normalize();
				ray.set(prey.pos, point);
				//debugger;
				var intersects = ray.intersectObjects(pickables2, true);
				if (intersects.length > 0) {
					console.log(intersects[0].object.name);
					if (intersects[0].object.name === "flag") {
						behind = false; //找到
					} else behind = true;
				}
			}
			function onDocumentMouseDown(event) {
				event.preventDefault();
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
				// found = false;
				// find intersections
				raycaster.setFromCamera(mouse, camera);
				var intersects = raycaster.intersectObjects(pickables);
				if (intersects.length > 0) {
					flag.position.copy(intersects[0].point);
					flag.position.y = 8;
				}
			}

			function animate() {
				animate.distance = animate.distance ? animate.distance : 0;

				requestAnimationFrame(animate);
				render();
				let dt = clock.getDelta();

				update();
				predictor.update(dt);
				prey.update(dt);
				behindOrNot();
				//console.log(behind);
				//prey.showState();
				prey.findTarget(flag);
				var dst = prey.pos.distanceTo(flag.position);

				if (
					prey.fsm.state === "snatch" &&
					dst > animate.distance &&
					dst > 100
				) {
					prey.fsm.flagNoFound();
				}
				if (front === false) prey.fsm.flagNoFound();
				if (
					prey.fsm.state === "search" &&
					dst < animate.distance &&
					dst < 100
					//behind === false
				) {
					if (front === true) {
						if (behind === true) prey.fsm.flagNoFound();
						else prey.fsm.flagFound();
					}
				}

				//console.log (prey.fsm.state);

				animate.distance = dst;
			}

			function render() {
				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
